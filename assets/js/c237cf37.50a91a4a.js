"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[4819],{8414:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"simulation/gazebo-fundamentals","title":"Gazebo Fundamentals: Physics-Based Simulation for Humanoid Robots","description":"Introduction","source":"@site/docs/02-simulation/gazebo-fundamentals.md","sourceDirName":"02-simulation","slug":"/simulation/gazebo-fundamentals","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/simulation/gazebo-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/aneeq-ai/Humanoid-Robotics-Textbook/edit/master/my-website/docs/02-simulation/gazebo-fundamentals.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Simulation: Digital Twin for Humanoid Robotics","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/simulation/"},"next":{"title":"Unity Robotics: High-Fidelity Visual Simulation","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/simulation/unity-robotics"}}');var o=i(4848),s=i(8453);const a={},t="Gazebo Fundamentals: Physics-Based Simulation for Humanoid Robots",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Gazebo Architecture and Components",id:"gazebo-architecture-and-components",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Physics Engine",id:"physics-engine",level:4},{value:"Rendering Engine",id:"rendering-engine",level:4},{value:"Sensor Simulation",id:"sensor-simulation",level:4},{value:"Gazebo Simulation Pipeline",id:"gazebo-simulation-pipeline",level:3},{value:"Setting Up Gazebo for Humanoid Robotics",id:"setting-up-gazebo-for-humanoid-robotics",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Launch",id:"basic-launch",level:3},{value:"Robot Modeling with URDF and SDF",id:"robot-modeling-with-urdf-and-sdf",level:2},{value:"URDF vs. SDF",id:"urdf-vs-sdf",level:3},{value:"Key Considerations for Humanoid Robots",id:"key-considerations-for-humanoid-robots",level:3},{value:"Mass Distribution",id:"mass-distribution",level:4},{value:"Joint Limits and Dynamics",id:"joint-limits-and-dynamics",level:4},{value:"Contact Modeling",id:"contact-modeling",level:4},{value:"Gazebo Plugins for Humanoid Robots",id:"gazebo-plugins-for-humanoid-robots",level:2},{value:"ROS 2 Control Integration",id:"ros-2-control-integration",level:3},{value:"Sensor Plugins",id:"sensor-plugins",level:3},{value:"Physics Plugins",id:"physics-plugins",level:3},{value:"Creating Humanoid Robot Models",id:"creating-humanoid-robot-models",level:2},{value:"Basic Humanoid Structure",id:"basic-humanoid-structure",level:3},{value:"Example Humanoid Configuration",id:"example-humanoid-configuration",level:3},{value:"Simulation Scenarios for Humanoid Robots",id:"simulation-scenarios-for-humanoid-robots",level:2},{value:"Locomotion Testing",id:"locomotion-testing",level:3},{value:"Manipulation Tasks",id:"manipulation-tasks",level:3},{value:"Perception Challenges",id:"perception-challenges",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simulation Speed",id:"simulation-speed",level:3},{value:"Stability Considerations",id:"stability-considerations",level:3},{value:"Debugging and Visualization",id:"debugging-and-visualization",level:2},{value:"Gazebo GUI Tools",id:"gazebo-gui-tools",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:3},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:2},{value:"Launch Files",id:"launch-files",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Model Development",id:"model-development",level:3},{value:"Simulation Design",id:"simulation-design",level:3},{value:"Performance",id:"performance",level:3},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"gazebo-fundamentals-physics-based-simulation-for-humanoid-robots",children:"Gazebo Fundamentals: Physics-Based Simulation for Humanoid Robots"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo is a powerful, open-source robotics simulator that provides high-fidelity physics simulation, realistic sensor models, and a rich development environment. For humanoid robotics, Gazebo enables the testing and validation of complex locomotion, manipulation, and perception algorithms in a safe, controlled environment."}),"\n",(0,o.jsx)(e.p,{children:"This section covers the essential concepts and techniques for using Gazebo effectively in humanoid robotics applications."}),"\n",(0,o.jsx)(e.h2,{id:"gazebo-architecture-and-components",children:"Gazebo Architecture and Components"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.h4,{id:"physics-engine",children:"Physics Engine"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ODE (Open Dynamics Engine)"}),": Default engine, good for general-purpose simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Bullet"}),": Fast and robust, suitable for complex contact scenarios"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simbody"}),": Multi-body dynamics engine, good for biomechanical simulations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"DART"}),": Dynamic Animation and Robotics Toolkit, advanced contact handling"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"rendering-engine",children:"Rendering Engine"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"OGRE"}),": 3D rendering engine for visualization"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"OpenGL"}),": Hardware-accelerated graphics rendering"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GUI"}),": Interactive user interface for simulation control"]}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides realistic simulation of various sensors:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Cameras (RGB, depth, stereo)"}),"\n",(0,o.jsx)(e.li,{children:"LIDAR and 2D/3D laser scanners"}),"\n",(0,o.jsx)(e.li,{children:"IMU sensors"}),"\n",(0,o.jsx)(e.li,{children:"Force/torque sensors"}),"\n",(0,o.jsx)(e.li,{children:"GPS and magnetometer"}),"\n",(0,o.jsx)(e.li,{children:"Joint position, velocity, and effort sensors"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"gazebo-simulation-pipeline",children:"Gazebo Simulation Pipeline"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Model Loading"}),": Robot and environment models are loaded"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Physics Update"}),": Physics engine calculates forces and movements"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor Update"}),": Simulated sensors generate data based on the current state"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Rendering"}),": Visualization is updated for the GUI"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Communication"}),": Data is published to ROS topics or other interfaces"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"setting-up-gazebo-for-humanoid-robotics",children:"Setting Up Gazebo for Humanoid Robotics"}),"\n",(0,o.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo can be installed as part of the ROS ecosystem:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo with ROS 2\r\nsudo apt update\r\nsudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins\r\n\r\n# Or install standalone Gazebo Garden\r\nsudo apt install gazebo-garden\n"})}),"\n",(0,o.jsx)(e.h3,{id:"basic-launch",children:"Basic Launch"}),"\n",(0,o.jsx)(e.p,{children:"To launch Gazebo with a simple empty world:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Using ROS 2 launch\r\nros2 launch gazebo_ros empty_world.launch.py\r\n\r\n# Or standalone\r\ngazebo\n"})}),"\n",(0,o.jsx)(e.h2,{id:"robot-modeling-with-urdf-and-sdf",children:"Robot Modeling with URDF and SDF"}),"\n",(0,o.jsx)(e.h3,{id:"urdf-vs-sdf",children:"URDF vs. SDF"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"URDF (Unified Robot Description Format)"})," is used primarily in ROS and describes robot kinematics and visual properties:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="simple_humanoid">\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.1"/>\r\n      </geometry>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.2 0.1 0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n</robot>\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"SDF (Simulation Description Format)"})," is Gazebo's native format and includes physics and simulation-specific properties:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.7">\r\n  <model name="simple_humanoid">\r\n    <link name="base_link">\r\n      <pose>0 0 0.1 0 0 0</pose>\r\n      <visual name="visual">\r\n        <geometry>\r\n          <box>\r\n            <size>0.2 0.1 0.1</size>\r\n          </box>\r\n        </geometry>\r\n      </visual>\r\n      <collision name="collision">\r\n        <geometry>\r\n          <box>\r\n            <size>0.2 0.1 0.1</size>\r\n          </box>\r\n        </geometry>\r\n      </collision>\r\n      <inertial>\r\n        <mass>1.0</mass>\r\n        <inertia>\r\n          <ixx>0.01</ixx>\r\n          <ixy>0.0</ixy>\r\n          <ixz>0.0</ixz>\r\n          <iyy>0.01</iyy>\r\n          <iyz>0.0</iyz>\r\n          <izz>0.01</izz>\r\n        </inertia>\r\n      </inertial>\r\n    </link>\r\n  </model>\r\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"key-considerations-for-humanoid-robots",children:"Key Considerations for Humanoid Robots"}),"\n",(0,o.jsx)(e.h4,{id:"mass-distribution",children:"Mass Distribution"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Accurate mass properties are crucial for stable locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Use CAD software to calculate mass properties when possible"}),"\n",(0,o.jsx)(e.li,{children:"Consider the impact of payloads and accessories"}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"joint-limits-and-dynamics",children:"Joint Limits and Dynamics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Set realistic joint limits based on physical constraints"}),"\n",(0,o.jsx)(e.li,{children:"Configure damping and friction to match real-world behavior"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate gear ratios and motor characteristics"}),"\n"]}),"\n",(0,o.jsx)(e.h4,{id:"contact-modeling",children:"Contact Modeling"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Configure contact stiffness and damping for stable contact"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate friction coefficients for different materials"}),"\n",(0,o.jsx)(e.li,{children:"Consider the impact of foot geometry on walking stability"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"gazebo-plugins-for-humanoid-robots",children:"Gazebo Plugins for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"ros-2-control-integration",children:"ROS 2 Control Integration"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"gazebo_ros_control"})," plugin allows integration with ROS 2 control framework:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\r\n    <parameters>$(find my_robot_description)/config/my_robot_controllers.yaml</parameters>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"sensor-plugins",children:"Sensor Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides various sensor plugins that can be integrated into URDF:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="camera_link">\r\n  <sensor name="camera" type="camera">\r\n    <update_rate>30</update_rate>\r\n    <camera name="head">\r\n      <horizontal_fov>1.3962634</horizontal_fov>\r\n      <image>\r\n        <width>800</width>\r\n        <height>600</height>\r\n        <format>R8G8B8</format>\r\n      </image>\r\n      <clip>\r\n        <near>0.1</near>\r\n        <far>100</far>\r\n      </clip>\r\n    </camera>\r\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\r\n      <frame_name>camera_optical_frame</frame_name>\r\n      <topic_name>image_raw</topic_name>\r\n    </plugin>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-plugins",children:"Physics Plugins"}),"\n",(0,o.jsx)(e.p,{children:"For humanoid robots, you might need custom physics plugins for:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Custom contact processing"}),"\n",(0,o.jsx)(e.li,{children:"External force application"}),"\n",(0,o.jsx)(e.li,{children:"Specialized control algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Integration with external simulators"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"creating-humanoid-robot-models",children:"Creating Humanoid Robot Models"}),"\n",(0,o.jsx)(e.h3,{id:"basic-humanoid-structure",children:"Basic Humanoid Structure"}),"\n",(0,o.jsx)(e.p,{children:"A humanoid robot typically includes:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Torso"}),": Main body with sensors and computing"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Head"}),": With cameras, microphones, and displays"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Arms"}),": With shoulders, elbows, wrists, and hands"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Legs"}),": With hips, knees, ankles, and feet"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Joints"}),": With appropriate ranges of motion"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"example-humanoid-configuration",children:"Example Humanoid Configuration"}),"\n",(0,o.jsxs)(e.p,{children:["For a complete example of a humanoid robot model, see the ",(0,o.jsx)(e.code,{children:"code-examples/gazebo-unity-examples/humanoid.urdf"})," file which contains a detailed 18-DOF humanoid model with:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Torso and head with appropriate mass properties"}),"\n",(0,o.jsx)(e.li,{children:"Two legs with hip, knee, and ankle joints"}),"\n",(0,o.jsx)(e.li,{children:"Two arms with shoulder, elbow, and wrist joints"}),"\n",(0,o.jsx)(e.li,{children:"Proper inertial properties for stable simulation"}),"\n",(0,o.jsx)(e.li,{children:"Gazebo plugin configuration for ROS control"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Here's an excerpt showing the main torso and head definition:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="simple_humanoid">\r\n\r\n  \x3c!-- Base/Pelvis Link --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.2 0.25 0.3"/>\r\n      </geometry>\r\n      <material name="light_grey">\r\n        <color rgba="0.7 0.7 0.7 1.0"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.2 0.25 0.3"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="10.0"/>\r\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.2"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Torso --\x3e\r\n  <joint name="pelvis_torso_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="torso"/>\r\n    <origin xyz="0.0 0.0 0.25" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <link name="torso">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.25 0.25 0.4"/>\r\n      </geometry>\r\n      <material name="light_grey">\r\n        <color rgba="0.7 0.7 0.7 1.0"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.25 0.25 0.4"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="8.0"/>\r\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.2"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Head --\x3e\r\n  <joint name="torso_head_joint" type="fixed">\r\n    <parent link="torso"/>\r\n    <child link="head"/>\r\n    <origin xyz="0.0 0.0 0.35" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  <link name="head">\r\n    <visual>\r\n      <geometry>\r\n        <sphere radius="0.1"/>\r\n      </geometry>\r\n      <material name="light_grey">\r\n        <color rgba="0.7 0.7 0.7 1.0"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <sphere radius="0.1"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="2.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Additional joints and links for complete humanoid continue in the full file... --\x3e\r\n</robot>\n'})}),"\n",(0,o.jsxs)(e.p,{children:["To launch this humanoid robot in Gazebo, use the launch file provided in ",(0,o.jsx)(e.code,{children:"code-examples/gazebo-unity-examples/launch/humanoid_sim.launch.py"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import os\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.conditions import IfCondition\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Package and file paths\r\n    pkg_gazebo_ros = FindPackageShare('gazebo_ros')\r\n\r\n    # Launch configuration variables\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n    use_rviz = LaunchConfiguration('use_rviz')\r\n\r\n    # Declare launch arguments\r\n    declare_use_sim_time_cmd = DeclareLaunchArgument(\r\n        name='use_sim_time',\r\n        default_value='true',\r\n        description='Use simulation (Gazebo) clock if true'\r\n    )\r\n\r\n    # Start Gazebo server\r\n    start_gazebo_server_cmd = IncludeLaunchDescription(\r\n        PythonLaunchDescriptionSource(\r\n            os.path.join(pkg_gazebo_ros, 'launch', 'gzserver.launch.py')\r\n        ),\r\n        launch_arguments={\r\n            'world': os.path.join(\r\n                FindPackageShare('gazebo_unity_examples').find('gazebo_unity_examples'),\r\n                'worlds',\r\n                'empty.world'\r\n            ),\r\n            'verbose': 'true',\r\n            'pause': 'false'\r\n        }.items()\r\n    )\r\n\r\n    # Robot State Publisher node\r\n    robot_state_publisher_cmd = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        name='robot_state_publisher',\r\n        output='screen',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'robot_description': get_robot_description(  # This function reads the URDF\r\n                PathJoinSubstitution([FindPackageShare('gazebo_unity_examples'), 'urdf', 'humanoid.urdf'])\r\n            )\r\n        }]\r\n    )\r\n\r\n    # ... (additional nodes and configuration)\r\n\r\n    ld = LaunchDescription()\r\n    ld.add_action(declare_use_sim_time_cmd)\r\n    ld.add_action(start_gazebo_server_cmd)\r\n    ld.add_action(robot_state_publisher_cmd)\r\n    # ... (additional actions)\r\n\r\n    return ld\r\n\r\ndef get_robot_description(urdf_path):\r\n    \"\"\"Read the URDF file and return its content as a string.\"\"\"\r\n    with open(urdf_path, 'r') as infp:\r\n        robot_desc = infp.read()\r\n    return {'robot_description': robot_desc}\n"})}),"\n",(0,o.jsx)(e.p,{children:"To run the simulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Launch the humanoid robot in Gazebo\r\nros2 launch gazebo_unity_examples humanoid_sim.launch.py\n"})}),"\n",(0,o.jsx)(e.h2,{id:"simulation-scenarios-for-humanoid-robots",children:"Simulation Scenarios for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"locomotion-testing",children:"Locomotion Testing"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Walking on flat ground"}),"\n",(0,o.jsx)(e.li,{children:"Stair climbing"}),"\n",(0,o.jsx)(e.li,{children:"Obstacle navigation"}),"\n",(0,o.jsx)(e.li,{children:"Balance recovery from disturbances"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"manipulation-tasks",children:"Manipulation Tasks"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Object grasping and manipulation"}),"\n",(0,o.jsx)(e.li,{children:"Tool usage"}),"\n",(0,o.jsx)(e.li,{children:"Bimanual coordination"}),"\n",(0,o.jsx)(e.li,{children:"Human-robot interaction scenarios"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"perception-challenges",children:"Perception Challenges"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Object recognition in cluttered environments"}),"\n",(0,o.jsx)(e.li,{children:"Human pose estimation"}),"\n",(0,o.jsx)(e.li,{children:"Dynamic scene understanding"}),"\n",(0,o.jsx)(e.li,{children:"Multi-modal sensor fusion"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"simulation-speed",children:"Simulation Speed"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjust physics engine parameters for desired speed"}),"\n",(0,o.jsx)(e.li,{children:"Reduce model complexity where appropriate"}),"\n",(0,o.jsx)(e.li,{children:"Use simplified collision models for non-critical components"}),"\n",(0,o.jsx)(e.li,{children:"Optimize sensor update rates"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"stability-considerations",children:"Stability Considerations"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Proper time step selection"}),"\n",(0,o.jsx)(e.li,{children:"Appropriate contact parameters"}),"\n",(0,o.jsx)(e.li,{children:"Adequate joint damping"}),"\n",(0,o.jsx)(e.li,{children:"Realistic actuator dynamics"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"debugging-and-visualization",children:"Debugging and Visualization"}),"\n",(0,o.jsx)(e.h3,{id:"gazebo-gui-tools",children:"Gazebo GUI Tools"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Model and joint visualization"}),"\n",(0,o.jsx)(e.li,{children:"Force and torque display"}),"\n",(0,o.jsx)(e.li,{children:"Sensor data visualization"}),"\n",(0,o.jsx)(e.li,{children:"Physics properties inspection"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Jittering joints: Adjust damping or increase physics update rate"}),"\n",(0,o.jsx)(e.li,{children:"Penetrating objects: Increase contact stiffness or adjust time step"}),"\n",(0,o.jsx)(e.li,{children:"Unstable walking: Verify mass properties and contact parameters"}),"\n",(0,o.jsx)(e.li,{children:"Slow simulation: Simplify models or adjust physics parameters"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,o.jsx)(e.h3,{id:"launch-files",children:"Launch Files"}),"\n",(0,o.jsx)(e.p,{children:"Example launch file for humanoid simulation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.actions import Node\r\nfrom launch_ros.substitutions import FindPackageShare\r\n\r\ndef generate_launch_description():\r\n    # Launch configuration variables\r\n    model = LaunchConfiguration('model')\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n\r\n    # Declare launch arguments\r\n    declare_model_path = DeclareLaunchArgument(\r\n        name='model',\r\n        default_value='path/to/humanoid.urdf',\r\n        description='Absolute path to robot urdf file'\r\n    )\r\n\r\n    declare_use_sim_time = DeclareLaunchArgument(\r\n        name='use_sim_time',\r\n        default_value='true',\r\n        description='Use simulation (Gazebo) clock if true'\r\n    )\r\n\r\n    # Start Gazebo server\r\n    start_gazebo_server_cmd = Node(\r\n        package='gazebo_ros',\r\n        executable='gzserver',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        arguments=['-s', 'libgazebo_ros_init.so',\r\n                   '-s', 'libgazebo_ros_factory.so'],\r\n        output='screen'\r\n    )\r\n\r\n    # Start Gazebo client\r\n    start_gazebo_client_cmd = Node(\r\n        package='gazebo_ros',\r\n        executable='gzclient',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        output='screen'\r\n    )\r\n\r\n    # Robot State Publisher\r\n    robot_state_publisher_cmd = Node(\r\n        package='robot_state_publisher',\r\n        executable='robot_state_publisher',\r\n        parameters=[{'use_sim_time': use_sim_time,\r\n                    'robot_description': model}],\r\n        output='screen'\r\n    )\r\n\r\n    # Spawn robot in Gazebo\r\n    spawn_entity_cmd = Node(\r\n        package='gazebo_ros',\r\n        executable='spawn_entity.py',\r\n        arguments=['-entity', 'humanoid_robot',\r\n                   '-topic', 'robot_description'],\r\n        output='screen'\r\n    )\r\n\r\n    # Create launch description\r\n    ld = LaunchDescription()\r\n\r\n    # Add actions to launch description\r\n    ld.add_action(declare_model_path)\r\n    ld.add_action(declare_use_sim_time)\r\n    ld.add_action(start_gazebo_server_cmd)\r\n    ld.add_action(start_gazebo_client_cmd)\r\n    ld.add_action(robot_state_publisher_cmd)\r\n    ld.add_action(spawn_entity_cmd)\r\n\r\n    return ld\n"})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"model-development",children:"Model Development"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Start with simple models and gradually increase complexity"}),"\n",(0,o.jsx)(e.li,{children:"Validate each component before integration"}),"\n",(0,o.jsx)(e.li,{children:"Use consistent units throughout the model"}),"\n",(0,o.jsx)(e.li,{children:"Document assumptions and limitations"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"simulation-design",children:"Simulation Design"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Create reproducible simulation conditions"}),"\n",(0,o.jsx)(e.li,{children:"Log simulation parameters for result validation"}),"\n",(0,o.jsx)(e.li,{children:"Use realistic noise models for sensors"}),"\n",(0,o.jsx)(e.li,{children:"Validate simulation results against physical robots when possible"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"performance",children:"Performance"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Profile simulation performance regularly"}),"\n",(0,o.jsx)(e.li,{children:"Balance accuracy with computational requirements"}),"\n",(0,o.jsx)(e.li,{children:"Use appropriate model simplifications"}),"\n",(0,o.jsx)(e.li,{children:"Consider parallel simulation for testing"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides a powerful platform for humanoid robotics simulation, offering physics-based simulation, sensor modeling, and integration with ROS 2. Proper configuration of robot models, physics parameters, and simulation scenarios is essential for effective humanoid robot development and testing."}),"\n",(0,o.jsx)(e.p,{children:"In the next sections, we'll explore Unity for high-fidelity visual simulation and how to integrate both platforms for comprehensive humanoid robotics development."})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>t});var r=i(6540);const o={},s=r.createContext(o);function a(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);